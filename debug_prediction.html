<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Debug Prediction</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            padding: 20px;
            background: #1e1e1e;
            color: #d4d4d4;
            max-width: 1200px;
            margin: 0 auto;
        }
        h1 { color: #61afef; }
        .output {
            background: #252526;
            border: 1px solid #3e3e42;
            padding: 15px;
            margin: 10px 0;
            border-radius: 4px;
            font-size: 13px;
        }
        .error { color: #f48771; background: #3a1a1a; }
        .success { color: #89d185; background: #1a3a1a; }
        .warning { color: #e5c07b; background: #3a3a1a; }
        .info { color: #61afef; }
        button {
            background: #0e639c;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px;
            font-weight: bold;
        }
        button:hover { background: #1177bb; }
        pre { 
            background: #1e1e1e;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <h1>üîç Student Placement Prediction - Debug Tool</h1>
    
    <div>
        <button onclick="testModelLoading()">1Ô∏è‚É£ Load & Inspect Model</button>
        <button onclick="testSamplePrediction()">2Ô∏è‚É£ Test Sample Prediction</button>
        <button onclick="testProblematicInput()">3Ô∏è‚É£ Test Your Input (IQ=130)</button>
        <button onclick="clearOutput()">üóëÔ∏è Clear</button>
    </div>
    
    <div id="output"></div>

    <script>
        let modelData = null;
        
        function log(message, type = 'info') {
            const output = document.getElementById('output');
            const div = document.createElement('div');
            div.className = `output ${type}`;
            div.innerHTML = message;
            output.appendChild(div);
            console.log(message.replace(/<[^>]*>/g, ''));
        }
        
        function clearOutput() {
            document.getElementById('output').innerHTML = '';
        }
        
        async function testModelLoading() {
            clearOutput();
            log('üìÇ Loading models.json...', 'info');
            
            try {
                const response = await fetch('models.json');
                modelData = await response.json();
                
                log('‚úÖ Model loaded successfully!', 'success');
                log(`<strong>Model Structure:</strong><pre>${JSON.stringify({
                    scaler_features: modelData.scaler.feature_names.length,
                    scaler_mean_length: modelData.scaler.mean.length,
                    scaler_scale_length: modelData.scaler.scale.length,
                    coefficients_length: modelData.logistic_regression.coefficients.length,
                    intercept: modelData.logistic_regression.intercept
                }, null, 2)}</pre>`, 'info');
                
                log(`<strong>Feature Names (${modelData.scaler.feature_names.length}):</strong><br>${modelData.scaler.feature_names.map((name, i) => `${i}. ${name}`).join('<br>')}`, 'info');
                
                log(`<strong>Scaler Mean Values:</strong><pre>${modelData.scaler.mean.map((v, i) => `[${i}] ${v.toFixed(4)}`).join('\n')}</pre>`, 'info');
                
                log(`<strong>Scaler Scale Values:</strong><pre>${modelData.scaler.scale.map((v, i) => `[${i}] ${v.toFixed(4)}`).join('\n')}</pre>`, 'info');
                
            } catch (error) {
                log(`‚ùå Error loading model: ${error.message}`, 'error');
                console.error(error);
            }
        }
        
        function prepareFeatures(inputs) {
            const features = [
                inputs.iq,                                              // 0: IQ
                inputs.prevSem,                                         // 1: Prev_Sem_Result
                inputs.cgpa,                                            // 2: CGPA
                inputs.academicPerf,                                    // 3: Academic_Performance
                inputs.internship,                                      // 4: Internship_Experience
                inputs.extraCurricular,                                 // 5: Extra_Curricular_Score
                inputs.communication,                                   // 6: Communication_Skills
                inputs.projects,                                        // 7: Projects_Completed
                inputs.cgpa * inputs.communication,                     // 8: CGPA_x_Communication
                inputs.iq * inputs.academicPerf,                        // 9: IQ_x_Academic_Performance
                inputs.projects * inputs.internship,                    // 10: Projects_x_Internship
                inputs.cgpa * inputs.cgpa,                              // 11: CGPA_squared
                inputs.iq * inputs.iq,                                  // 12: IQ_squared
                inputs.academicPerf * inputs.academicPerf,              // 13: Academic_Performance_squared
                inputs.communication * inputs.communication             // 14: Communication_Skills_squared
            ];
            return features;
        }
        
        function standardizeFeatures(features) {
            const mean = modelData.scaler.mean;
            const scale = modelData.scaler.scale;
            
            return features.map((val, idx) => (val - mean[idx]) / scale[idx]);
        }
        
        function sigmoid(z) {
            return 1 / (1 + Math.exp(-z));
        }
        
        function makePrediction(inputs) {
            const features = prepareFeatures(inputs);
            const scaledFeatures = standardizeFeatures(features);
            
            const coef = modelData.logistic_regression.coefficients;
            const intercept = modelData.logistic_regression.intercept;
            
            let z = intercept;
            for (let i = 0; i < scaledFeatures.length; i++) {
                z += coef[i] * scaledFeatures[i];
            }
            
            const probability = sigmoid(z);
            const prediction = probability >= 0.5 ? 1 : 0;
            
            return { features, scaledFeatures, z, probability, prediction };
        }
        
        async function testSamplePrediction() {
            clearOutput();
            
            if (!modelData) {
                log('‚ö†Ô∏è Model not loaded. Loading now...', 'warning');
                await testModelLoading();
                log('<br><hr><br>', 'info');
            }
            
            log('üß™ <strong>Testing Sample Input</strong>', 'info');
            
            const inputs = {
                iq: 110,
                prevSem: 8.5,
                cgpa: 8.2,
                academicPerf: 7,
                internship: 1,
                extraCurricular: 6,
                communication: 7,
                projects: 3
            };
            
            log(`<strong>Input Values:</strong><pre>${JSON.stringify(inputs, null, 2)}</pre>`, 'info');
            
            const result = makePrediction(inputs);
            
            log(`<strong>Raw Features (15):</strong><pre>${result.features.map((v, i) => `[${i}] ${modelData.scaler.feature_names[i]}: ${v}`).join('\n')}</pre>`, 'info');
            
            const hasNaN = result.scaledFeatures.some(f => isNaN(f));
            log(`<strong>Scaled Features (15):</strong><pre>${result.scaledFeatures.map((v, i) => 
                `[${i}] ${isNaN(v) ? '‚ùå NaN' : v.toFixed(6)}`).join('\n')}</pre>`, 
                hasNaN ? 'error' : 'success');
            
            if (!hasNaN) {
                log(`<strong>‚úÖ Prediction Result:</strong><br>
                     Logit (z): ${result.z.toFixed(4)}<br>
                     Probability: <strong>${(result.probability * 100).toFixed(2)}%</strong><br>
                     Prediction: <strong>${result.prediction === 1 ? '‚úì PLACED' : '‚úó NOT PLACED'}</strong>`, 'success');
            } else {
                log('‚ùå <strong>NaN values detected in scaled features!</strong>', 'error');
            }
        }
        
        async function testProblematicInput() {
            clearOutput();
            
            if (!modelData) {
                log('‚ö†Ô∏è Model not loaded. Loading now...', 'warning');
                await testModelLoading();
                log('<br><hr><br>', 'info');
            }
            
            log('üß™ <strong>Testing Your Problematic Input</strong>', 'warning');
            
            const inputs = {
                iq: 130,
                prevSem: 9,
                cgpa: 9,
                academicPerf: 9,
                internship: 1,
                extraCurricular: 8,
                communication: 9,
                projects: 5
            };
            
            log(`<strong>Input Values:</strong><pre>${JSON.stringify(inputs, null, 2)}</pre>`, 'info');
            
            const result = makePrediction(inputs);
            
            log(`<strong>Raw Features (15):</strong><pre>${result.features.map((v, i) => `[${i}] ${modelData.scaler.feature_names[i]}: ${v}`).join('\n')}</pre>`, 'info');
            
            const nanIndices = [];
            result.scaledFeatures.forEach((v, i) => {
                if (isNaN(v)) nanIndices.push(i);
            });
            
            const hasNaN = nanIndices.length > 0;
            
            log(`<strong>Scaled Features (15):</strong><pre>${result.scaledFeatures.map((v, i) => {
                if (isNaN(v)) {
                    return `[${i}] ‚ùå NaN (raw: ${result.features[i]}, mean: ${modelData.scaler.mean[i]}, scale: ${modelData.scaler.scale[i]})`;
                }
                return `[${i}] ${v.toFixed(6)}`;
            }).join('\n')}</pre>`, hasNaN ? 'error' : 'success');
            
            if (hasNaN) {
                log(`<strong>‚ùå Found ${nanIndices.length} NaN values at indices: ${nanIndices.join(', ')}</strong>`, 'error');
                log(`<strong>Debugging NaN values:</strong><pre>${nanIndices.map(i => {
                    const raw = result.features[i];
                    const mean = modelData.scaler.mean[i];
                    const scale = modelData.scaler.scale[i];
                    const scaled = (raw - mean) / scale;
                    return `Index ${i} (${modelData.scaler.feature_names[i]}):\n  Raw value: ${raw}\n  Mean: ${mean}\n  Scale: ${scale}\n  Calculation: (${raw} - ${mean}) / ${scale} = ${scaled}\n  Is scale zero? ${scale === 0}\n  Is scale undefined? ${scale === undefined}`;
                }).join('\n\n')}</pre>`, 'error');
            } else {
                log(`<strong>‚úÖ Prediction Result:</strong><br>
                     Logit (z): ${result.z.toFixed(4)}<br>
                     Probability: <strong>${(result.probability * 100).toFixed(2)}%</strong><br>
                     Prediction: <strong>${result.prediction === 1 ? '‚úì PLACED' : '‚úó NOT PLACED'}</strong>`, 'success');
            }
        }
        
        // Auto-load model on page load
        window.onload = () => {
            log('üöÄ <strong>Debug Tool Ready</strong><br>Click the buttons above to start testing.', 'info');
        };
    </script>
</body>
</html>
